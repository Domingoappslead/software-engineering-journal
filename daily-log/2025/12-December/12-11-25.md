# 2025-12-11 — Daily Learning Log

## What I Learned Today
- Make Methods Do One Thing (Single Responsibility at the Method Level)

### Exact Definition
- A method should do one thing, do it well, and do it only.
- If you need to add “and then it also does…” when explaining a method, that method violates clean code principles.

### Simpler Explanation
- A method should handle one unit of behavior. If it handles multiple concerns, split it into smaller methods.

## Key Takeaways / Important Concepts
- A cashier does one responsibility: process payments.
- They do not also bake bread, clean the floors, and approve returns.
- When one person has many responsibilities, the entire workflow becomes fragile.
- Same for methods.

## Code Example or Concept Practiced
- Bad Example
This method updates a product and logs the update and clears cache:
```csharp
public async Task<Product> UpdateProductAsync(Product product)
{
    var updated = await _repo.UpdateAsync(product);
    
    _logger.LogInformation("Product updated: {Id}", product.Id);

    await _cache.RemoveAsync($"product:{product.Id}");
    await _cache.RemoveAsync("product:list");

    return updated;
}
```

- This method is doing:
    1. Data update
    2. Logging
    3. Cache invalidation
- Three responsibilities → Not clean.

- Clean Example (Split Into Purpose-Focused Methods)
```csharp
public async Task<Product> UpdateProductAsync(Product product)
{
    var updated = await _repo.UpdateAsync(product);
    await InvalidateProductCacheAsync(product.Id);
    LogProductUpdate(product.Id);

    return updated;
}

private void LogProductUpdate(Guid id)
{
    _logger.LogInformation("Product updated: {Id}", id);
}

private async Task InvalidateProductCacheAsync(Guid id)
{
    await _cache.RemoveAsync($"product:{id}");
    await _cache.RemoveAsync("product:list");
}
```
- Now:
| Method | Responsibility |
| :--- | :--- |
| UpdateProductAsync | Orchestrates update flow |
| LogProductUpdate | Handles logging only |
| InvalidateProductCacheAsync | Handles cache invalidation only |

- Readable, maintainable, testable.

## Why This Matters (Reasoning You Should Internalize)
1. Easier debugging – when something breaks, you know exactly where the failure is.
2. Easier unit testing – small methods are trivial to test.
3. Better reusability – smaller methods can be reused in other flows.
4. Cleaner architecture – helps you move toward proper separation between layers.

## Confusions / Questions I Still Have
- None

## Small Win of the Day
- Learned clean code principle

## Next Steps for Tomorrow
- Learn Csharp syntax-fundamentals

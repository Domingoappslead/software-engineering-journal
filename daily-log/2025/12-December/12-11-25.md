# 2025-12-11 — Daily Learning Log

## What I Learned Today
### Make Methods Do One Thing  
**Focus:** Single Responsibility at the method level.


## Exact Definition
A method must perform **one** behavior, perform it **well**, and perform **only that** behavior.  
If you can describe a method and naturally say, “and then it also does…”, the method is violating clean code principles.


## Simpler Explanation
A method should represent one unit of work.  
If it mixes concerns, break it into smaller, focused methods.


## Key Takeaways / Important Concepts
A cashier processes payments.  
They do not also bake bread, mop floors, and approve returns.

When one person carries multiple unrelated responsibilities, the workflow becomes harder to maintain.  
Methods behave the same way.

Single-responsibility methods make your code less fragile and easier to reason about.

## Code Example/Concept Practiced

### Bad Example
This method updates the product **and** logs **and** clears cache:

```csharp
public async Task<Product> UpdateProductAsync(Product product)
{
    var updated = await _repo.UpdateAsync(product);
    
    _logger.LogInformation("Product updated: {Id}", product.Id);

    await _cache.RemoveAsync($"product:{product.Id}");
    await _cache.RemoveAsync("product:list");

    return updated;
}
```

 This method is doing:
1. Data update
2. Logging
3. Cache invalidation

Three responsibilities → Not clean.


#### Clean Example (Split Into Purpose-Focused Methods)
```csharp
public async Task<Product> UpdateProductAsync(Product product)
{
    var updated = await _repo.UpdateAsync(product);
    await InvalidateProductCacheAsync(product.Id);
    LogProductUpdate(product.Id);

    return updated;
}

private void LogProductUpdate(Guid id)
{
    _logger.LogInformation("Product updated: {Id}", id);
}

private async Task InvalidateProductCacheAsync(Guid id)
{
    await _cache.RemoveAsync($"product:{id}");
    await _cache.RemoveAsync("product:list");
}
```
| **Method**                    | **Responsibility**              |
| ----------------------------- | ------------------------------- |
| `UpdateProductAsync`          | Orchestrates update flow        |
| `LogProductUpdate`            | Handles logging only            |
| `InvalidateProductCacheAsync` | Handles cache invalidation only |

 Now: Readable, maintainable, testable.

---

## Why This Matters (Reasoning You Should Internalize)
1. Easier debugging – when something breaks, you know exactly where the failure is.
2. Easier unit testing – small methods are trivial to test.
3. Better reusability – smaller methods can be reused in other flows.
4. Cleaner architecture – helps you move toward proper separation between layers.

## Confusions / Questions I Still Have
None


## Small Win of the Day
Learned clean code principle


## Next Steps for Tomorrow
Learn Csharp syntax-fundamentals